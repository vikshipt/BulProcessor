/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.hti.user;

import com.logica.smpp.Connection;
import com.logica.smpp.Data;
import com.logica.smpp.Receiver;
import com.logica.smpp.Transmitter;
import com.logica.smpp.pdu.PDU;
import com.logica.smpp.pdu.PDUException;
import com.logica.smpp.pdu.Request;
import com.logica.smpp.pdu.Response;
import java.io.IOException;
import org.apache.log4j.Logger;

/**
 * This class represent one client connection to the server starting by
 * accepting the connection, authenticating of the client, communication and
 * finished by unbinding. The <code>SMSCSession</code> object is generated by
 * <code>SMSCListener</code> which also sets the session's PDU processor.
 * Session is run in separate thread; it reads PDUs from the connection and
 * calls PDU processor's client methods to process the received PDUs. PDU
 * processor on turn can use the session to submit PDUs to the client. For
 * receiving and sending of PDUs the session uses instances of
 * <code>Receiver</code> and <code>Transmitter</code>.
 *
 * @author Logica Mobile Networks SMPP Open Source Team
 * @version $Revision: 1.2 $
 * @see SMSCListener
 * @see PDUProcessor
 * @see Connection
 * @see Receiver
 * @see Transmitter
 */
public class UserSession implements Runnable {

    private Logger logger = Logger.getLogger(UserSession.class);
    private Receiver receiver;
    private Transmitter transmitter;
    private PDUProcessor pduProcessor;
    private Connection connection;
    private long receiveTimeout = Data.RECEIVER_TIMEOUT;
    private boolean keepReceiving = true;
    private boolean isReceiving = false;
    private int timeoutCntr = 0;

    /**
     * Initialises the session with the connection the session should
     * communicate over.
     *
     * @param connection the connection object for communication with client
     */
    public UserSession(Connection connection) {
        this.connection = connection;
        transmitter = new Transmitter(connection);
        receiver = new Receiver(transmitter, connection);
    }

    /**
     * Signals the session's thread that it should stop. Doesn't wait for the
     * thread to be completly finished. Note that it can take some time before
     * the thread is completly stopped.
     *
     * @see #run()
     */
    public void stop() {
        logger.debug("SMSCSession stopping");
        keepReceiving = false;
    }

    /**
     * Implements the logic of receiving of the PDUs from client and passing
     * them to PDU processor. First starts receiver, then in cycle receives PDUs
     * and passes them to the proper PDU processor's methods. After the function
     * <code>stop</code> is called (externally) stops the receiver, exits the
     * PDU processor and closes the connection, so no extry tidy-up routines are
     * necessary.
     *
     * @see #stop()
     * @see PDUProcessor#clientRequest(Request)
     * @see PDUProcessor#clientResponse(Response)
     */
    public void run() {
        PDU pdu = null;

        logger.trace("SMSCSession run()");
        logger.debug("SMSCSession starting receiver");
        receiver.start();
        isReceiving = true;
        try {
            while (keepReceiving) {
                try {
                    logger.debug("SMSCSession going to receive a PDU");
                    pdu = receiver.receive(getReceiveTimeout());
                } catch (Exception e) {
                    logger.debug("SMSCSession caught exception receiving PDU " + e.getMessage());
                }

                if (pdu != null) {
                    timeoutCntr = 0;
                    if (pdu.isRequest()) {
                        logger.debug("SMSCSession got request " + pdu.debugString());
                        pduProcessor.clientRequest((Request) pdu);
                    } else if (pdu.isResponse()) {
                        logger.debug("SMSCSession got response " + pdu.debugString());
                        pduProcessor.clientResponse((Response) pdu);
                    } else {
                        logger.debug("SMSCSession not reqest nor response => not doing anything.");
                    }
                } else {
                    timeoutCntr++;
                    if (timeoutCntr > 5) {
                        logger.debug("SMSCSession stoped due to inactivity");
                        stop();
                    }
                }
            }
        } finally {
            isReceiving = false;
        }
        logger.debug("SMSCSession stopping receiver");
        receiver.stop();
        logger.debug("SMSCSession exiting PDUProcessor");
        pduProcessor.exit();
        try {
            logger.debug("SMSCSession closing connection");
            connection.close();
        } catch (IOException e) {
            logger.debug("closing Session Error." + e);
        }
        logger.debug("SMSCSession exiting run()");
    }

    /**
     * Sends a PDU to the client.
     *
     * @param pdu the PDU to send
     */
    public void send(PDU pdu) throws IOException, PDUException {
        timeoutCntr = 0;
        logger.debug("SMSCSession going to send pdu over transmitter");
        transmitter.send(pdu);
        logger.debug("SMSCSession pdu sent over transmitter");
    }

    /**
     * Sets new PDU processor.
     *
     * @param pduProcessor the new PDU processor
     */
    public void setPDUProcessor(PDUProcessor pduProcessor) {
        this.pduProcessor = pduProcessor;
    }

    /**
     * Sets the timeout for receiving the complete message.
     *
     * @param timeout the new timeout value
     */
    public void setReceiveTimeout(long timeout) {
        receiveTimeout = timeout;
    }

    /**
     * Returns the current setting of receiving timeout.
     *
     * @return the current timeout value
     */
    public long getReceiveTimeout() {
        return receiveTimeout;
    }

    /**
     * Returns the details about the account that is logged in to this session
     *
     * @return An object representing the account. It is casted to the correct
     * type by the implementation
     */
    public Object getAccount() {
        return null;
    }

    /**
     * Set details about the account that is logged in to this session
     *
     * @param account An object representing the account. It is casted to the
     * correct type by the implementation
     */
    public void setAccount(Object account) {
    }

    /**
     * @return Returns the isReceiving.
     */
    public boolean isReceiving() {
        return isReceiving;
    }

    /**
     * @param isReceiving The isReceiving to set.
     */
    public void setReceiving(boolean isReceiving) {
        this.isReceiving = isReceiving;
    }

    public Connection getConnection() {
        return connection;
    }
}
